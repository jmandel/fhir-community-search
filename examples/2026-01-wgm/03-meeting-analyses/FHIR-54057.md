# FHIR-54057: Clean up conditional* elements in CapabilityStatement

## Issue Overview

This ballot comment from Hayden Bader (Epic) points out that several boolean fields in CapabilityStatement related to conditional interactions have become redundant. The fields in question are:

- `conditionalUpdate` (0..1 boolean)
- `conditionalCreate` (0..1 boolean)
- `conditionalPatch` (0..1 boolean)

These fields were added before R6 to indicate server support for conditional versions of these interactions. However, R6 introduced new codes in the `interaction` element that directly represent these capabilities: `update-conditional`, `create-conditional`, and `patch-conditional`. This means the same information can now be expressed in two different places in the CapabilityStatement.

The commenter notes that `conditionalRead` is different because it's a code (with values like `not-supported`, `modified-since`, `not-match`, `full-support`) rather than a simple boolean, so it provides richer information than just a presence/absence indicator. Similarly, `conditionalDelete` is a code with values indicating the level of support (`not-supported`, `single`, `multiple`), and while there are now `delete-conditional-single` and `delete-conditional-multiple` interaction codes, the `conditionalDelete` code provides a cleaner single-valued representation.

## Current State

The CapabilityStatement resource currently has:

**Interaction codes (on rest.resource.interaction):**
- `update-conditional` - Conditional update
- `create-conditional` - Conditional create  
- `patch-conditional` - Conditional patch
- `delete-conditional-single` - Single conditional delete
- `delete-conditional-multiple` - Multiple conditional delete

**Separate fields (on rest.resource):**
- `conditionalCreate` (boolean) - If allows/uses conditional create
- `conditionalUpdate` (boolean) - If allows/uses conditional update
- `conditionalPatch` (boolean) - If allows/uses conditional patch
- `conditionalRead` (code) - How conditional read is supported
- `conditionalDelete` (code) - How conditional delete is supported

This creates ambiguity: if a server lists `update-conditional` in interactions but `conditionalUpdate` is false (or absent), what should clients infer?

## Stakeholder Perspectives

**Reporter (Hayden Bader/Epic):** Argues these boolean fields are redundant and should be cleaned up since the information is now expressible via interaction codes.

No other comments have been added to this issue yet.

## Related Issues & Discussions

- **FHIR-14444** (Published): "CapabilityStatement is questionable for normative this round" - Historical concern about CapabilityStatement complexity
- **FHIR-20196** (Published): Extension expectation context on CapabilityStatement
- No significant Zulip discussions found specifically about this redundancy

## Technical Considerations

1. **Backward Compatibility**: Removing these fields would be a breaking change. Deprecating them would be less disruptive.

2. **Semantic Precision**: The boolean fields can only express "supported" vs "not supported", while interaction codes express what capabilities are actually offered. However, absence of a code is ambiguous (not supported vs. not declared).

3. **conditionalRead vs conditionalDelete**: These coded fields provide more granular information than a simple boolean or interaction code presence. `conditionalRead` specifically has no corresponding interaction codes, so it cannot be removed.

4. **Consistency**: Having some conditional capabilities as separate fields and others only as interaction codes creates inconsistency in how to express/query conditional support.

5. **Search/Query Impact**: Implementations may be searching on these boolean fields. Removal would require query updates.

## Potential Courses of Action

### Option A: Deprecate Boolean Fields
- **Description**: Mark `conditionalCreate`, `conditionalUpdate`, and `conditionalPatch` as deprecated in R6. Recommend using interaction codes instead. Remove in a future version.
- **Pros**: 
  - Provides migration path for implementers
  - Maintains backward compatibility in R6
  - Cleaner model long-term
- **Cons**: 
  - Deprecation creates implementation guidance complexity
  - Two ways to express same thing during transition
- **Impact**: Non-breaking (compatible, substantive change)

### Option B: Remove Boolean Fields Now
- **Description**: Remove the redundant boolean fields (`conditionalCreate`, `conditionalUpdate`, `conditionalPatch`) from R6.
- **Pros**:
  - Clean, single way to express capabilities
  - No ambiguity about which to use
- **Cons**:
  - Breaking change for existing implementations
  - May affect IGs that profile CapabilityStatement
- **Impact**: Breaking (non-compatible change)

### Option C: Keep as Is with Clarifying Documentation
- **Description**: Keep all fields but add documentation clarifying the relationship and recommended usage patterns.
- **Pros**:
  - No breaking changes
  - Flexibility for different use cases
- **Cons**:
  - Perpetuates redundancy
  - Implementers must handle both patterns
- **Impact**: Non-substantive (documentation only)

### Option D: Align conditionalDelete Treatment
- **Description**: Consider whether `conditionalDelete` should also be deprecated given the new `delete-conditional-single` and `delete-conditional-multiple` codes, or whether the coded fields provide sufficient additional value to justify keeping them.
- **Pros**:
  - Comprehensive review of all conditional fields
  - Consistent approach
- **Cons**:
  - `conditionalDelete` codes provide more semantic information than boolean
  - Scope creep from original issue
- **Impact**: Varies by decision

## Questions for the Workgroup

1. Do the interaction codes provide sufficient expressiveness to replace the boolean fields, or is there value in the explicit "supports conditional X" boolean pattern?

2. Should `conditionalDelete` be treated differently because it's a code with multiple values rather than a boolean?

3. What is the deprecation timeline policy for removing elements from normative resources?

4. Are there known implementations relying heavily on searching/filtering by these boolean fields?

5. Should we add `meaningWhenMissing` to clarify what absent boolean fields mean vs absent interaction codes?

## References

- [CapabilityStatement Resource](https://build.fhir.org/capabilitystatement.html)
- [Jira Issue FHIR-54057](https://jira.hl7.org/browse/FHIR-54057)
- Section 5.3.4 of FHIR Core Specification
