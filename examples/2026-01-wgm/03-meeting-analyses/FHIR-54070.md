# FHIR-54070: Subscription.filterBy.comparator seems redundant

## Issue Overview

This ballot comment from James Jahns identifies that `Subscription.filterBy.comparator` appears to be redundant because the comparator can be (and is documented as) included directly in the `Subscription.filterBy.value` field.

The commenter provides two key observations:

1. **Documentation shows comparator in value**: The description for `filterBy.value` explicitly shows comparators being included in the value itself: "The literal value or resource path as is legal in search - for example, `Patient/123` or `le1950`."

2. **OR logic limitation**: `filterBy.comparator` is 0..1 (single value), which doesn't support scenarios requiring multiple comparators. For example, filtering for extreme values would need both `lt` and `gt`: `filterBy.value = lt50,gt100`.

The suggestion is to remove `filterBy.comparator` and have `filterBy.value` contain the complete query parameter value including the comparator prefix.

## Current State

The `Subscription.filterBy` backbone element contains:

- `resource` (0..1 uri) - Allowed Resource for this filter
- `filterParameter` (1..1 string) - Filter label defined in SubscriptionTopic
- `comparator` (0..1 code) - eq | ne | gt | lt | ge | le | sa | eb | ap
- `modifier` (0..1 code) - missing | exact | contains | not | text | in | not-in | below | above | type | identifier | of-type | code-text | text-advanced | iterate
- `value` (1..1 string) - Literal value or resource path

There's also a constraint that filters may only contain a modifier OR a comparator (not both).

## Stakeholder Perspectives

**Reporter (James Jahns):** Argues for removing `comparator` as redundant, since comparators can be embedded in `value`.

No other comments on this issue yet.

**Related Issue - FHIR-54856 (Gino Canessa):** Notes that optional coded elements in Subscription (`filterBy.comparator`, `filterBy.modifier`, `content`, `contentType`) need `meaningWhenMissing` to ensure consistent default behavior across implementations.

## Related Issues & Discussions

- **FHIR-54856** (Triaged): "Subscription optional coded elements need to describe default behavior" - Related concern about what happens when comparator/modifier are absent
- No significant Zulip discussions found on this specific topic

## Technical Considerations

1. **Search Parameter Alignment**: FHIR search uses prefix notation (`le1950`, `gt5`) within the parameter value. Having a separate `comparator` field deviates from this pattern.

2. **OR Logic**: Search parameters support OR logic within values (`lt50,gt100`). The single-valued `comparator` field cannot express this, forcing the comparator into the value anyway for these cases.

3. **Parsing Complexity**: Having comparator both as a separate field AND potentially embedded in value creates parsing ambiguity. Implementations must handle both patterns.

4. **Explicit vs Implicit**: The separate `comparator` field makes the operator explicit and structured, which could aid in validation, documentation, and tooling support.

5. **SubscriptionTopic Alignment**: How does this relate to how SubscriptionTopic defines its filter parameters?

6. **Breaking Change**: Removing `comparator` would be a breaking change for implementations that populate/read this field.

7. **Default Behavior**: If `comparator` is kept, what does absence mean? This ties to FHIR-54856.

## Potential Courses of Action

### Option A: Remove comparator Field
- **Description**: Remove `Subscription.filterBy.comparator` and document that comparators should be included as prefixes in `filterBy.value`, following standard FHIR search notation.
- **Pros**:
  - Aligns with FHIR search parameter conventions
  - Supports OR logic with multiple comparators
  - Eliminates redundancy and parsing ambiguity
  - Simpler model
- **Cons**:
  - Breaking change for existing implementations
  - Loss of structured/explicit comparator for tooling
  - Requires parsing value to extract comparator
- **Impact**: Non-compatible (breaking change)

### Option B: Keep comparator but Clarify Relationship
- **Description**: Keep both fields but add clear documentation:
  - If `comparator` is provided, it applies to `value`
  - If `comparator` is absent, `value` may contain embedded comparator(s)
  - Define precedence if both are present
- **Pros**:
  - Backward compatible
  - Supports both explicit and inline comparators
  - Structured field available for simple cases
- **Cons**:
  - Maintains redundancy
  - Complex rules for implementers
  - Two ways to do the same thing
- **Impact**: Non-substantive (clarification)

### Option C: Make comparator Repeating
- **Description**: Change `comparator` from 0..1 to 0..* to support OR logic, and clarify that inline comparators in value should not be used when the field is populated.
- **Pros**:
  - Addresses OR logic limitation
  - Maintains structured representation
- **Cons**:
  - Still redundant with value capability
  - More complex than just using value
  - Breaking change for implementations expecting single value
- **Impact**: Non-compatible (cardinality change)

### Option D: Deprecate comparator
- **Description**: Mark `comparator` as deprecated, recommend using inline notation in `value`, plan for removal in future version.
- **Pros**:
  - Provides migration path
  - Signals direction without immediate breakage
  - Allows implementations time to adapt
- **Cons**:
  - Deprecation period maintains complexity
  - Two patterns during transition
- **Impact**: Compatible, substantive (deprecation)

### Option E: Add meaningWhenMissing Only
- **Description**: Keep structure as-is but address FHIR-54856 by adding `meaningWhenMissing` to clarify that absent `comparator` means "eq" (equality) unless embedded in value.
- **Pros**:
  - Addresses immediate clarity concern
  - No structural changes
  - Consistent default behavior
- **Cons**:
  - Doesn't address fundamental redundancy
  - Still allows confusing combinations
- **Impact**: Non-substantive (clarification)

## Questions for the Workgroup

1. Was there a deliberate design reason for having `comparator` as a separate field rather than just using the search parameter notation?

2. How do existing Subscription implementations handle the comparator field? Is it widely used?

3. Should the pattern match FHIR search parameters (comparator as prefix in value) or is there value in the structured field for Subscriptions specifically?

4. If keeping `comparator`, what should the default be when it's absent? Is this `eq`, or does it mean "look in value"?

5. How does this interact with SubscriptionTopic filter parameter definitions?

6. Should the same discussion apply to `modifier`?

## References

- [Subscription Resource](https://build.fhir.org/subscription.html)
- [Jira Issue FHIR-54070](https://jira.hl7.org/browse/FHIR-54070)
- [FHIR-54856: Subscription optional coded elements](https://jira.hl7.org/browse/FHIR-54856)
- [FHIR Search - Prefixes](https://build.fhir.org/search.html#prefix)
