# FHIR-54073: Terminology functions should be fluent like most fhirpath functions

## Issue Overview

This ballot comment from Brian Postlethwaite argues that the `%terminology` factory functions deviate from FHIRPath's predominantly fluent design pattern and proposes replacing them with fluent-style functions. The existing fluent functions `memberOf()`, `subsumes()`, and `subsumedBy()` demonstrate this pattern already works well for terminology operations.

The commenter provides a comprehensive proposal for fluent terminology functions inspired by CSIRO's Pathling extensions, which would be more natural to use and consistent with FHIRPath conventions.

## Current State

The FHIRPath specification currently has:

**Existing fluent terminology functions:**
- `memberOf(valueSet)` - Check if a code is in a value set
- `subsumes(code)` - Check if the input code subsumes the parameter
- `subsumedBy(code)` - Check if the input code is subsumed by the parameter

**Factory-style functions (`%terminology.xxx`):**
- `%terminology.expand(valueSet, params)`
- `%terminology.lookup(coding, params)`
- `%terminology.validate(valueSet, codedValue, params)`
- `%terminology.translate(conceptMap, coding, params)`
- `%terminology.subsumes(system, codeA, codeB, params)`
- `%terminology.at(url)`

## Stakeholder Perspectives

**Reporter (Brian Postlethwaite):** Proposes replacing factory functions with fluent alternatives:

- `useTerminologyServer(url)` - Set terminology server context (like `defineVariable`)
- `display([language])` - Get display value for code/coding
- `designation(use, [language])` - Get designation for coding
- `property(code, [language])` - Get code property value
- `translate(conceptmapUrl, reverse, equivalence, targetSystem, [sourceSystem])` - Translate codes
- `validateCode(system, [date], [language], [abstract])` - Validate a code
- `expandValueSet()` - Expand a value set

These would work on input collections of `code`, `Coding`, or `CodeableConcept` types.

## Related Issues & Discussions

- **FHIR-54069** (Triaged): "Extensive refinements/extensions to the terminology fhirpath extensions" - Related documentation and params concerns
- **FHIR-53953** (Triaged): "No documentation on remote interactions" - Remote service handling

**Zulip Discussions:**
- The #fhirpath "Object creation" thread includes discussion about factory vs. fluent patterns, with Paul Lynch (fhirpath.js) noting that fhirpath.js implements the %factory approach but the new fluent/constructor syntax is "definitely more concise and readable."

## Technical Considerations

1. **FHIRPath Design Philosophy**: FHIRPath is designed around fluent, chainable functions operating on collections. Factory-style functions (`%something.xxx()`) are an exception to this pattern.

2. **Pathling Precedent**: CSIRO's Pathling has implemented fluent terminology functions that have real-world usage, providing implementation experience.

3. **Context Propagation**: The proposed `useTerminologyServer()` would modify evaluation context for downstream functions, similar to `defineVariable()`. This pattern exists but needs careful specification.

4. **Type Handling**: Fluent functions naturally handle the input type (code, Coding, CodeableConcept) without separate parameters.

5. **Backward Compatibility**: Replacing factory functions with fluent ones is a breaking change for any implementations using the current API.

6. **Normative Concerns**: These functions are proposed for normative status. The design should be validated before locking in.

7. **Parameter Handling**: The `params` issue from FHIR-54069 applies here too - how to pass optional/advanced parameters to terminology operations.

## Potential Courses of Action

### Option A: Replace Factory with Fluent Functions
- **Description**: Remove `%terminology.xxx` factory functions and add the proposed fluent functions (`display()`, `designation()`, `property()`, `translate()`, etc.).
- **Pros**:
  - Consistent with FHIRPath design philosophy
  - More natural syntax for users
  - Natural handling of input types
  - Precedent in Pathling implementation
- **Cons**:
  - Breaking change for factory function users
  - Significant spec rewrite
  - May need `params` equivalent for advanced options
- **Impact**: Non-compatible (breaking change)

### Option B: Add Fluent Functions Alongside Factory
- **Description**: Keep existing factory functions and add new fluent functions as alternatives. Document when to use each.
- **Pros**:
  - No breaking changes
  - Users can choose preferred style
  - Incremental improvement
- **Cons**:
  - Two ways to do the same thing
  - Increased specification complexity
  - Implementation burden to support both
- **Impact**: Compatible, substantive change

### Option C: Move Factory to Incubator, Add Fluent
- **Description**: Move `%terminology` factory functions to an incubator IG. Add fluent functions to the normative spec.
- **Pros**:
  - Clean normative spec with fluent pattern
  - Factory functions available for those who need them
  - Allows parallel evolution
- **Cons**:
  - Splitting functionality across specs
  - Migration complexity
- **Impact**: Non-compatible (removing from normative)

### Option D: Defer Fluent Changes to Post-R6
- **Description**: Document the factory functions better for R6 (per FHIR-54069) and plan fluent redesign for a future version.
- **Pros**:
  - Stability for R6
  - Time for more design work
  - Can gather implementation feedback
- **Cons**:
  - Locks in potentially suboptimal design as normative
  - Harder to change later
- **Impact**: No structural change

### Option E: Comprehensive Fluent Redesign with useTerminologyServer
- **Description**: Implement the full proposal including `useTerminologyServer()` context modifier, with careful specification of how context propagates.
- **Pros**:
  - Complete solution
  - Clean context management
  - Addresses server selection (from FHIR-54069)
- **Cons**:
  - Largest change
  - `useTerminologyServer()` is novel pattern needing careful design
  - Implementation complexity
- **Impact**: Non-compatible (if replacing factory)

## Questions for the Workgroup

1. Is the FHIRPath fluent pattern a strong enough principle to justify breaking changes to the terminology API?

2. Are there use cases where the factory pattern is genuinely better than fluent functions?

3. What implementation experience exists with both patterns? Has Pathling's fluent approach proven successful?

4. How should the `useTerminologyServer()` context modifier work? Should it affect only subsequent chained operations, or set a context variable?

5. Should the `weight()` function be replaced with the more general `property()` function?

6. What's the relationship between `%terminology.subsumes()` and the existing fluent `subsumes()`/`subsumedBy()`? Can we just enhance the fluent versions?

7. How do we handle advanced parameters (date, language, abstract) that the full terminology operations support?

## References

- [FHIRPath Terminology Service API](https://build.fhir.org/fhirpath.html#txapi)
- [Jira Issue FHIR-54073](https://jira.hl7.org/browse/FHIR-54073)
- [FHIR-54069: Terminology extensions refinements](https://jira.hl7.org/browse/FHIR-54069)
- [Pathling FHIRPath Extensions](https://pathling.csiro.au/docs/fhirpath)
- Section 2.1.9.4 of FHIR Core Specification
