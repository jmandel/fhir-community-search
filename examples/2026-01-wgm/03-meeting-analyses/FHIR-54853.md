# FHIR-54853: Finalize the 'not' Search Modifier

## Issue Overview

This issue addresses the ambiguous behavior of the `:not` search modifier when used with "or-joined" parameter values (comma-separated values). The current specification includes cautionary text indicating that the `not` modifier can behave in "undesirable ways" with or-joined values, and recommends against this usage.

The specific problem is illustrated with an example: searching for `gender:not=male,female` on a scalar field. Using default rules, this query expands to the union of:
- Patients that do not have gender "male" (including those with "female" or no value)
- Patients that do not have gender "female" (including those with "male" or no value)

The union of these two sets will always contain all records, which is almost certainly not what the searcher intended.

The issue requests that the behavior be either clearly described (so implementers know what to expect) or prohibited (to prevent misuse).

## Current State

The current specification contains warning text about this behavior:

> "Implementer feedback is requested on this behavior and if additional rules concerning the not modifier would be appropriate. In the meantime, use of the not modifier with 'or'-joined search terms is not recommended. Implementers are instead recommended to use either the _filter parameter or Named Queries."

This text has been in place as a placeholder while seeking implementer feedback. The behavior is technically defined (as a union of negated individual values), but the result is counterintuitive and rarely useful.

## Stakeholder Perspectives

**Gino Canessa** (Reporter): Filed this ballot comment requesting a decision - either describe the behavior formally or prohibit it.

No comments yet on this specific issue, and minimal Zulip discussion found on the `:not` modifier specifically. Historical discussions around search negation have generally focused on the `:not-in` modifier for reference searches rather than the `:not` modifier on token parameters.

## Related Issues & Discussions

- Limited direct related issues found
- The `_filter` parameter provides an alternative mechanism for complex negation logic
- Named Queries can be defined to handle specific negation use cases

## Technical Considerations

1. **Set Logic**: The current behavior follows strict set logic (union of individually negated sets), which is mathematically consistent but practically useless for the common use case.

2. **Intended Use Case**: Users likely expect `gender:not=male,female` to mean "gender is NOT in {male, female}" (intersection of negations), not "gender is NOT male OR gender is NOT female" (union of negations).

3. **Cardinality Matters**: The problem is most acute for scalar (max cardinality 1) elements. For repeating elements, the behavior might occasionally be useful.

4. **De Morgan's Law**: The intuitive interpretation (intersection of negations) would be `NOT(male OR female)` = `NOT male AND NOT female`, but FHIR search doesn't have native AND-within-OR support.

5. **Alternatives Exist**: The `_filter` parameter can express complex logic: `_filter=not(gender eq "male" or gender eq "female")`

6. **Breaking Change Risk**: Changing the behavior to the "intuitive" interpretation would be a breaking change for any implementation relying on current behavior (though such usage seems unlikely).

## Potential Courses of Action

### Option A: Prohibit :not with OR-joined Values
- **Description**: Servers SHALL return an error if `:not` modifier is used with comma-separated values. Clients wanting this logic must use `_filter` or multiple AND-joined parameters.
- **Pros**: Clear, unambiguous; prevents misuse; simple to implement
- **Cons**: Restricts functionality; may break existing queries (though they were likely wrong)
- **Impact**: Breaking change for clients using this pattern; servers must add validation

### Option B: Change Semantics to Intersection
- **Description**: Define `param:not=a,b` to mean "NOT (a OR b)" rather than "(NOT a) OR (NOT b)"
- **Pros**: Matches user expectations; more useful semantically
- **Cons**: Breaking change; inconsistent with how other modifiers apply to OR-joined values; complicates the search logic model
- **Impact**: Non-compatible, substantive change

### Option C: Formally Document Current Behavior with Strong Warning
- **Description**: Keep current behavior but add clear normative documentation explaining exactly what happens, with a warning that this is rarely the intended behavior
- **Pros**: No breaking change; educational value
- **Cons**: Perpetuates a confusing feature; doesn't solve the underlying problem
- **Impact**: Non-substantive clarification

### Option D: Deprecate :not in Favor of :not-eq
- **Description**: Introduce a new modifier `:not-eq` with intersection semantics; deprecate `:not` usage with warning
- **Pros**: Preserves backward compatibility; provides clear path forward
- **Cons**: Adds complexity; creates two ways to do similar things
- **Impact**: Compatible, substantive change; eventual deprecation

## Questions for the Workgroup

1. Has any implementer reported actual usage of `:not` with OR-joined values? If so, what was the intent?

2. Should we prioritize consistency with the existing search model (OR-joined values are unions) or user expectations (negation should apply to the whole set)?

3. Is the `_filter` parameter sufficiently supported that we can require its use for complex negation logic?

4. Should the solution differ based on element cardinality (scalar vs repeating)?

5. Is there a compelling reason to maintain the current behavior, or can we treat it as a specification bug to be corrected?

## References

- [FHIR-54853 Jira Issue](https://jira.hl7.org/browse/FHIR-54853)
- [FHIR Search Page - Modifiers](https://build.fhir.org/search.html#modifiers)
- [FHIR Search Page - Multiple Values](https://build.fhir.org/search.html#combining)
- [FHIR _filter Parameter](https://build.fhir.org/search_filter.html)
